1 - create-next-app . // ставим приложение на nextjs

2 - Ставим тайпскрипт в проект. Для этого:
    - touch tsconfig.json // добавляем файл конфига
    - yarn add -D typescript @types/react @types/node // ставим тайпскрипт и типы

3 - Структура каталогов:
    .next - скомпилированные статические файлы, там мы не торчим
    pages - структура страниц приложения (они строят роутинг, это зарезервированное название каталога)
    public - публичная папка для картинок, иконок, всякого хлама которое должно быть доступно извне
    styles - глобальные стили и стили модулей, но мы стили модулей будем хранить в папках модулей

4 - Head - для применения разных атрибутов блока <head> на любой странице. Большим приоритетом обладает тот
    который сильнее вложен. Элементы которые допускаются по многу типа link плюсуются. Но им можно указать
    атрибут key одинаковый и тогда они будут заменяться (вложенный снова в приоритете)
    Важно! В компоненте _document импортаруется Head из next/document а там где используется Head во внешних
    компонентах импортируется из next/head и импортируется по дефолту

5 - Если нам надо как то поменять структуру документа то мы можем создать в папке страниц файд _document.tsx
    где задаем структуру.

6 - React не надо импортировать в компонентах, видимо он импорируется где то выше
    как оказалось для React.Fragment надо импортировать реакт в компонент

7 - роутинг происходит автоматом, надо только в pages сделать реакт компонент с определенным названием
    файла и имя этого файла и будет нашим роутом
    Если нам надо сделать какой то компонент с динамическим параметром типа id то создаем каталог с именем роута
    а в каталоге создаем файл с таким именем: [id].tsx и экспортируем по дефолту компонент (всегда дефолт!)
    Нужный нам параметр мы можем получить на фронте через роутер:
    const { query: { id } } = useRouter(); // импортируем useRouter хук из неста
    Также можно структурировать роуты вкладывая файлы в каталоги и будут вложенные роуты (прямо битрикс какой то)

8 - Ссылки на роуты надо делать через компонент Link чтобы не было перезагрузки страницы:
    <Link href="post/12"><a>Post</a></Link>

9 - Для подключения scss надо просто установить пакет sass и переименовать css в scss ну и поправить импорты

10 - Для успешного ССР при получении асинхронных данных с сервера не годится получение их на фронте и рендер обычным
    реакт способом, в результате будет инициализирующее значение в рендере статики. Что делаем? Добавляем к нашему
    компоненту статический метод getInitialProps, где и делаем обработку асинхронных запросов. А результат возврата
    нам надо оформить как объект который потом передается в пропсы компонента и используются для отдачи данных
    Тогда первичный рендер статики происходит с полученными пропсами и сео-роботы их увидят
    Метод рабочий но устаревший, правильно использовать другие методы https://nextjs.org/docs/api-reference/data-fetching/getInitialProps
    ----- дополнение -----
    Нижеперечисленные функции исполняются только на сервере и могут использоваться только на страницах не в компонентах
    Для статического рендеринга используются функции:
      getStaticProps() - если данные для сборки уже доступны, данные могут быть публично закешированы, страница должна быть доступна для индексирования
        function Page({res}: InferGetStaticPropsType<typeof getStaticProps>): JSX.Element { return <></>; }
        export default Page;
        export const getStaticProps: GetStaticProps<IPageProps> = async ({params}: GetStaticPropsContext<ParseUrlQuery>) {
          const res = await fetch('....');
          return { props: { res } };
        }
        interface IPageProps extend Record<string, unknown> { res: Response }
        Контекст который приходит в функцию:
          export type GetStaticPropsContext <Q extends ParseUrlQuery = ParseUrlQuery> = {
            params?: Q; // параметры роута если страница вида [id].tsx
            preview?: boolean; // true если страница нахордится в режиме preview
            previewData?: any; // данные для превью
            locale: string; // данные о языке для мультиязычных сайтов
            locales: string[]; // все поддерживаемые языки
            defaultLocale: string; // язык по умолчанию
          }
        Что можем отдать на выход:
        return {
          props: {}, // данные для страницы
          revalidate: 4, // число секунд после который произойдет перерендеринг
          redirect: { // опция для перенаправления пользователя
            destination: '/',
            permanent: false,
          },
          notFound: true, // отдача 404 страницы вместо запрашиваемой
        }

      getStaticPaths() - для рендера страниц с динамическими адресами
    Для SSR%
      getServerSideProps() - выполняется для каждого запроса, выполняем только если нам необходимо зарендерить
        страницу прямо во время запроса. Эта страница будет медленнее статики, например для персонализации страницы
        Не возвращает revalidate. Имеет расширенный контекст:
        export type GetServerSidePropsContext <Q extends ParseUrlQuery = ParseUrlQuery> = {
          req: IncomingMessage & { cookes: NextApiRequestCookies } // Объект запроса к http
          res: ServerResponse; // ответ сервера
          params?: Q; // параметры роута если страница вида [id].tsx
          query: ParseUrlQuery // квери параметры запроса
          preview?: boolean; // true если страница нахордится в режиме preview
          previewData?: any; // данные для превью
          resolverUrl: string; // нормализованный урл по которому прошел запрос
          locale: string; // данные о языке для мультиязычных сайтов
          locales: string[]; // все поддерживаемые языки
          defaultLocale: string; // язык по умолчанию
        }

11 - Можем поставить прогрессбар для показа загрузок но мне лень: https://www.npmjs.com/package/nextjs-progressbar

12 - Также тут можно писать свое серверное апи как в экспрессе

13 - можно создавать дотенв файлы где хранить переменные:
  .env - Для всех окружений
  .env.local - для локалки, все секреты
  .env.development - для yarn dev
  .env.production - для yarn start

14 - Router
  Link:
    href - путь куда перенаправлять (можно так: {pathname: '/search', query: { q: 'test' })
    as? - пусть который будет отображаться в строке браузера
    replace? - заменяет текущий элемент в истории
    scroll? - указывает скроллить ли страницу вверх при переходе (по умолчанию true)
    shallow? - указывает запускать ли сср функции или нет
    passHref? - указывать прокидывать ли href до чилдрена
    prefetch? - прездазгружать ли данные перед переходом (по умолчанию true)
  Если нам надо обернуть не ссылку а какой то функциональный компонент в <Link> то надо этому функциональному компоненту
  указать интерфейс:
    <Link href="/...." passHref><MyComp /></Link>
    const MyComp = React.ForwardRef<HTMLAnchorElement, HTMLProps<HTMLAnchorElement>>({href, onClick}, ref) => (
      <a href={href} onClick={onClick} ref={ref}>Link</a>
    )

  useRouter() - хук чисто некста, экспортируется из next/router

15 - Image - компонент next-а
  <Image
    quality={70}                  Качество сжатия
    priority={false}              Предзагрузка изображения
    src="..."                     Исходный файл
    width={100}                   Ширина изображения
    height={50}                   Высота изображения
    layout="fixed"                Параметр layout
    objectFit="fill"              Если layout fill
    objectPosition="left bottom"  Если layout fill (120px 50%), (left top)
    loading="lazy"                Когда загружать изображение
    unoptimized={false}           Оптимизировать ли картинки
    loader={MyLoader}             Свой загрузчик изображения
  />
  layout бывает:
    - fixed - изображение не меняется от адаптива
    - intrinsic - для меньших разрешений изображение будет сжиматься
    - responsive - для меньших сжимается для больших увеличивается
    - fill - будет растягиваться до границ родительского элемента
  objectFit:
    - fill - растягивается по родительскому размеру
    - contain - вписывается в родительском блоке
    - cover - заполняется с обрезкой
    - none - реальный размер с обрезкой
    - scale-down - сжимается
  Если нам надо тянуть картинки с внешних доменов то это надо указать в настройках next.config.js
    images: {
      domains: ['1.bp.blogspot.com'], - указываем что с этого домена будет тащиться фото
      deviceSizes: [640, 1200, 1980, 2048], - размеры респонсивных экранов
      imageSizes: [16, 64, 128, 400, 600] - размеры пошаговых картинок
    }





15 - useReducer


----------------------------------
